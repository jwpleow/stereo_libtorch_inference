#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <thread>
#include <atomic>
#include <memory>
#include <chrono>

#include <opencv2/core.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>

#include "utils/utils.h"
#include "thirdparty/SPSCQueue.h"

namespace Camera{

struct StereoCalibrationParameters
{
    // single camera width/height
    int image_width;
    int image_height;

    // intrinsics
    cv::Mat left_camera_matrix = cv::Mat::zeros(3, 3, CV_64F); // in pixels
    cv::Mat right_camera_matrix = cv::Mat::zeros(3, 3, CV_64F);
    cv::Mat left_dist_coeffs; // could be (1,5) to (1,14) depending on which distortion model used
    cv::Mat right_dist_coeffs;

    // extrinsics from stereoCalibrate - see https://docs.opencv.org/master/da/de9/tutorial_py_epipolar_geometry.html
    cv::Mat R = cv::Mat::zeros(3, 3, CV_64F); // rotation matrix
    cv::Mat T = cv::Mat::zeros(3, 1, CV_64F); // translation vector
    cv::Mat E = cv::Mat::zeros(3, 3, CV_64F); // essential matrix - describes 2nd camera relative to 1st
    cv::Mat F = cv::Mat::zeros(3, 3, CV_64F); // fundamental matrix - same info as essential matrix, along with information about the intrinsics of both cameras to relate the two cameras in pixel coords (maps a point in one image to an epiline in the other)

    // rectify transforms https://docs.opencv.org/master/d9/d0c/group__calib3d.html#ga617b1685d4059c6040827800e72ad2b6
    cv::Mat R1 = cv::Mat::zeros(3, 3, CV_64F); // R1 -> rotation matrix from 1st to 2nd camera https://py.plainenglish.io/the-depth-i-stereo-calibration-and-rectification-24da7b0fb1e0
    cv::Mat R2 = cv::Mat::zeros(3, 3, CV_64F); // R2 -> rotation matrix from 2nd to 1st camera
    cv::Mat P1 = cv::Mat::zeros(3, 4, CV_64F); // P1 -> projection/position matrix from 1st to 2nd camera
    cv::Mat P2 = cv::Mat::zeros(3, 4, CV_64F); // P2 -> position matrix from 2nd to 1st camera
    cv::Mat Q = cv::Mat::zeros(4, 4, CV_64F);  // disparity-to-depth mapping matrix - distance between cameras, focal length, etc to get disparity map

    // valid regions of interest for each camera
    cv::Rect valid_roi_1;
    cv::Rect valid_roi_2;
    // roi's with matched height/width and offset from the centre
    cv::Rect valid_matched_roi_1;
    cv::Rect valid_matched_roi_2;
    // distortion maps
    cv::Mat undistort_map_1_1, undistort_map_1_2; // left side camera maps for undistort + rectification
    cv::Mat undistort_map_2_1, undistort_map_2_2; // right side
};

class CameraBase
{
    public:
    CameraBase(const std::string& capture_string);
    virtual ~CameraBase();

    virtual void read(cv::Mat& frame);

    public:
    Utils::FPSCounter fps_counter; // float fps = fps_counter.getAvgFps()

    protected:
    // opens VideoCapture
    bool openVideoCapture(const std::string &capture_string);
    // updates last_frame
    void update();
    // starts update() in a thread
    void startUpdateThread();

    protected:
    int frame_width;
    int frame_height;

    cv::VideoCapture video_capture;
    rigtorp::SPSCQueue<cv::Mat> frame_buffer;
    cv::Mat last_frame;
    std::thread frame_read_thread;
    std::mutex frame_read_lock;
    std::atomic<bool> grabOn;
};


class StereoCamera : public CameraBase
{
    public:
    StereoCamera(const std::string& capture_string, const std::string& stereo_calib_file);
    ~StereoCamera();

    void read(cv::Mat& left, cv::Mat& right);

    public:

    StereoCalibrationParameters stereo_calib_params;

    protected:
    /* 
    apply the undistorting and rectification maps generated by initialiseStereoRectificationAndUndistortMap
    */
    void undistort(const cv::Mat &input_left, const cv::Mat &input_right, cv::Mat &output_left, cv::Mat &output_right);

    // load stereo calib params from the file given. example format given in CalibParams_Stereo.yml
    void loadStereoCalibParams(const std::string& stereo_calib_file);
    // splits the image into left and right half, making a deepcopy of original
    void splitImage(const cv::Mat &original, cv::Mat &left, cv::Mat &right);
    // crops the images by stereo_calib_params.valid_matched_roi calculated by calculateMatchedRoi()
    void cropRoi(const cv::Mat &input_left, const cv::Mat &input_right, cv::Mat &output_left, cv::Mat &output_right);

    // get the maps for undistorting efficiently
    // alpha should be -1 (default scaling) or from 0 to 1, with 0 => all black parts from the undistorted image removed, 1 => all valid pixels retained (see https://answers.opencv.org/question/101398/what-does-the-getoptimalnewcameramatrix-function-does/)
    void initialiseStereoRectificationAndUndistortMap(double alpha = -1.0);

    /* 
    calculates matching valid regions of interest for each camera, 
    based on the valid_roi's generated in stereoRectify()
    by matching their height, width, and distance from the centreline
    */
    void calculateMatchedRoi();

    protected:
    bool calibration_loaded = false;

};

} // namespace Camera